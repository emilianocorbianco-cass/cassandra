import 'package:flutter/material.dart';
import '../../app/theme/cassandra_colors.dart';
import 'models/mock_prediction_data.dart';
import 'models/pick_option.dart';
import 'models/prediction_match.dart';
import 'models/formatters.dart';
import 'widgets/prediction_match_card.dart';
import 'dart:math';
import 'package:flutter/foundation.dart';

import '../scoring/models/match_outcome.dart';
import '../scoring/scoring_engine.dart';
import 'package:cassandra/app/config/env.dart';
import 'package:cassandra/services/api_football/api_football_client.dart';
import 'package:cassandra/services/api_football/api_football_service.dart';
import 'package:cassandra/features/predictions/adapters/api_football_fixture_adapter.dart';
import '../../app/state/cassandra_scope.dart';
import '../scoring/adapters/api_football_outcome_adapter.dart';
import '../leaderboards/mock_season_data.dart';
import '../leaderboards/models/matchday_data.dart';
import 'predictions_matchday_page.dart';
import 'predictions_history_page.dart';
import '../scoring/models/score_breakdown.dart';

enum VisibilityChoice { private, public }

class PredictionsPage extends StatefulWidget {
  const PredictionsPage({super.key});

  @override
  State<PredictionsPage> createState() => _PredictionsPageState();
}

class _PredictionsPageState extends State<PredictionsPage> {
  
  bool _didInitDeps = false;
int _matchdayNumber = 20;

  late List<PredictionMatch> _matches;
  bool _usingRealFixtures = false;
  bool _loadingFixtures = false;
  DateTime? _fixturesUpdatedAt;

  final Map<String, PickOption> _picks = {};

  int _segment = 0; // 0 = futuri, 1 = passati

  VisibilityChoice? _submittedVisibility;
  DateTime? _submittedAt;
  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (_didInitDeps) return;
    _didInitDeps = true;

    // final appState = CassandraScope.of(context); // provided by caller
    _tryLoadRealFixtures(appState);
  }


  @override
  void initState() {
    super.initState();
    _matches = mockPredictionMatches();
//     _tryLoadRealFixtures();  // moved to didChangeDependencies
  }

  PickOption _pickFor(String matchId) {
    // final appState = CassandraScope.of(context); // provided by caller
    appState.ensureCurrentUserPicksLoaded();
    return appState.currentUserPicksByMatchId[matchId] ?? PickOption.none;
  }

  int get _pickedCount => _matches.where((m) => !_pickFor(m.id).isNone).length;

  int get _missingCount => _matches.length - _pickedCount;

  DateTime get _firstKickoff =>
      _matches.map((m) => m.kickoff).reduce((a, b) => a.isBefore(b) ? a : b);

  DateTime get _lockTime => _firstKickoff.subtract(const Duration(minutes: 30));

  bool get _locked => DateTime.now().isAfter(_lockTime);

  String get _matchdayLabel {
    final daysLabel = formatMatchdayDaysItalian(_matches.map((m) => m.kickoff));
    return 'giornata $_matchdayNumber - $daysLabel';
  }

  double? _oddsForPick(PredictionMatch match, PickOption pick) {
    switch (pick) {
      case PickOption.none:
        return null;
      case PickOption.home:
        return match.odds.home;
      case PickOption.draw:
        return match.odds.draw;
      case PickOption.away:
        return match.odds.away;
      case PickOption.homeDraw:
        return match.odds.homeDraw;
      case PickOption.drawAway:
        return match.odds.drawAway;
      case PickOption.homeAway:
        return match.odds.homeAway;
    }
  }

  double? get _averageOddsPlayed {
    final values = <double>[];
    for (final match in _matches) {
      final pick = _pickFor(match.id);
      final odds = _oddsForPick(match, pick);
      if (odds != null) values.add(odds);
    }
    if (values.isEmpty) return null;
    final sum = values.reduce((a, b) => a + b);
    return sum / values.length;
  }

  void _setPick(String matchId, PickOption pick) {
    // Lock: non permettere modifiche ai pick se la partita è già iniziata.
    final PredictionMatch? match = _matches.cast<PredictionMatch?>().firstWhere(
      (m) => m?.id == matchId,
      orElse: () => null,
    );

    if (match != null && DateTime.now().isAfter(match.kickoff)) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Partita già iniziata: pick bloccato')),
      );
      return;
    }

    setState(() => _picks[matchId] = pick);
    CassandraScope.of(context).setCurrentUserPick(matchId, pick);
  }

  void _clearPick(String matchId) {
    setState(() => _picks.remove(matchId));
    CassandraScope.of(context).setCurrentUserPick(matchId, PickOption.none);
  }

  Future<bool> _confirmSubmitIfMissing(int missing) async {
    final result = await showDialog<bool>(
      context: context,
      builder: (context) {
        return AlertDialog(
          content: Text(
            'Hai lasciato $missing partite senza pronostico.\n\n'
            'Regola Cassandra: per ogni partita non giocata verrà applicata '
            'una penalità pari a -quota più alta (tra 1/X/2) in fase di calcolo.\n\n'
            'Vuoi inviare comunque?',
          ),
          actions: [
            IconButton(
              tooltip: 'Storico',
              icon: const Icon(Icons.history),
              onPressed: () {
                Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (_) => const PredictionsHistoryPage(),
                  ),
                );
              },
            ),

            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Annulla'),
            ),
            FilledButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: const Text('Invia comunque'),
            ),
          ],
        );
      },
    );
    return result ?? false;
  }

  Future<void> _submit(VisibilityChoice visibility) async {
    if (_locked) return;

    final missing = _missingCount;
    if (missing > 0) {
      final ok = await _confirmSubmitIfMissing(missing);
      if (!ok) return;
      if (!mounted) return; // dopo await
    }

    if (!mounted) return;
    setState(() {
      _submittedVisibility = visibility;
      _submittedAt = DateTime.now();
    });

    final label = visibility == VisibilityChoice.public
        ? 'pubblica'
        : 'privata';
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Schedina inviata (visibilità: $label)')),
    );

    // Snapshot storico: salva i pick per questa giornata (così "passati" diventa vero)
    // final appState = CassandraScope.of(context); // provided by caller
    appState.ensureCurrentUserPicksHistoryLoaded();
    appState.ensureMatchdayMatchesLoaded();
    appState.ensureOutcomesHistoryLoaded();
    appState.saveCurrentUserPicksHistory(
      dayNumber: _matchdayNumber,
      picksByMatchId: _picks,
    );

    await appState.saveMatchdayMatchesSnapshot(
      matchdayNumber: _matchdayNumber,
      matches: _matches,
    );
    appState.ensureMatchesHistoryLoaded();
    appState.saveMatchesHistory(
      matchdayNumber: _matchdayNumber,
      matches: _matches,
    );
    // Se abbiamo outcomes disponibili, salvali anche nello storico (per punteggi stabili)
    final outcomesNow = <String, MatchOutcome>{
      for (final e in appState.effectivePredictionOutcomesByMatchId.entries)
        e.key: e.value,
    };
    if (outcomesNow.isNotEmpty) {
      appState.ensureOutcomesHistoryLoaded();
      appState.saveOutcomesHistory(
        dayNumber: _matchdayNumber,
        outcomesByMatchId: outcomesNow,
      );
    }
  }

  Future<void> _showDebugScorePreview() async {
    final rnd = Random();

    const outcomesList = [
      MatchOutcome.home,
      MatchOutcome.draw,
      MatchOutcome.away,
    ];

    final outcomes = <String, MatchOutcome>{};
    for (final m in _matches) {
      outcomes[m.id] = outcomesList[rnd.nextInt(outcomesList.length)];
    }

    final day = CassandraScoringEngine.computeDayScore(
      matches: _matches,
      picksByMatchId: _picks,
      outcomesByMatchId: outcomes,
    );

    if (!mounted) return;

    await showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) {
        final byId = {for (final b in day.matchBreakdowns) b.matchId: b};
        final height = MediaQuery.of(context).size.height * 0.75;

        return SafeArea(
          child: SizedBox(
            height: height,
            child: Padding(
              padding: const EdgeInsets.all(12),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  const Text(
                    'Debug: calcolo punteggio',
                    style: TextStyle(fontWeight: FontWeight.w700),
                  ),
                  const SizedBox(height: 10),
                  Text('base: ${formatOdds(day.baseTotal)}'),
                  Text('bonus: ${day.bonusPoints}'),
                  Text('totale: ${formatOdds(day.total)}'),
                  const SizedBox(height: 6),
                  Text('esatti: ${day.correctCount}/10'),
                  Text(
                    'quota media: ${day.averageOddsPlayed == null ? '-' : formatOdds(day.averageOddsPlayed!)}',
                  ),
                  const Divider(height: 20),
                  Expanded(
                    child: ListView.builder(
                      itemCount: _matches.length,
                      itemBuilder: (context, i) {
                        final m = _matches[i];
                        final b = byId[m.id]!;
                        final outcome = outcomes[m.id]!;
                        final pick = _pickFor(m.id);
                        final sign = b.basePoints >= 0 ? '+' : '';

                        return Padding(
                          padding: const EdgeInsets.symmetric(vertical: 6),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                '${m.homeTeam} - ${m.awayTeam}',
                                style: const TextStyle(
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                              Text(
                                'pick ${pick.label}  •  res ${outcome.label}  •  $sign${formatOdds(b.basePoints)}',
                              ),
                              if (b.note.isNotEmpty)
                                Text(
                                  b.note,
                                  style: const TextStyle(fontSize: 12),
                                ),
                            ],
                          ),
                        );
                      },
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  Future<void> _tryLoadRealFixtures(dynamic appState, {bool showLoader = false}) async {
    final key = Env.apiFootballKey;
    if (key == null) return; // in test o senza .env restiamo sui mock

    if (showLoader && mounted) {
      setState(() => _loadingFixtures = true);
    }

    // final appState = CassandraScope.of(context); // provided by caller
    final client = ApiFootballClient(
      apiKey: key,
      baseUrl: Env.baseUrl,
      useRapidApi: Env.useRapidApi,
      rapidApiHost: Env.rapidApiHost,
    );

    try {
      final service = ApiFootballService(client);
      final fixtures = await service.getNextSerieAFixtures(count: 80);
      final filteredFixtures = _filterMatchdayWindow(fixtures);

      final outcomes = outcomesByMatchIdFromFixtures(filteredFixtures);
      final matches = predictionMatchesFromFixtures(filteredFixtures);
      if (matches.isEmpty) return;

      if (!mounted) return;
      setState(() {
        _matches = matches;
        _usingRealFixtures = true;
        _fixturesUpdatedAt = DateTime.now();
      });

      // Salviamo le fixture reali in cache runtime (per Gruppo / User pages)
      appState.setCachedPredictionMatches(
        matches,
        isReal: true,
        updatedAt: _fixturesUpdatedAt,
      );
      appState.setCachedPredictionOutcomesByMatchId(outcomes);
    } catch (_) {
      // Se fallisce la rete o la key, restiamo sui mock.
    } finally {
      client.close();
      if (showLoader && mounted) {
        setState(() => _loadingFixtures = false);
      }
    }
  }

  Map<String, PickOption> _demoPicksForMatchday(
    String seed,
    List<PredictionMatch> matches,
  ) {
    final rnd = Random(seed.hashCode);

    PickOption randomPick() {
      final x = rnd.nextDouble();

      if (x < 0.10) return PickOption.none;

      if (x < 0.75) {
        const singles = [PickOption.home, PickOption.draw, PickOption.away];
        return singles[rnd.nextInt(singles.length)];
      }

      const doubles = [
        PickOption.homeDraw,
        PickOption.drawAway,
        PickOption.homeAway,
      ];
      return doubles[rnd.nextInt(doubles.length)];
    }

    final picks = <String, PickOption>{};
    for (final m in matches) {
      picks[m.id] = randomPick();
    }
    return picks;
  }

  Widget _buildHistory(BuildContext context) {
    // final appState = CassandraScope.of(context); // provided by caller
    appState.ensureCurrentUserPicksLoaded();

    final uid = appState.profile.id;

    final liveMatches = appState.cachedPredictionMatches ?? _matches;

    final liveOutcomes = appState.hasSavedOutcomesForMatchday(_matchdayNumber)
        ? appState.outcomesForMatchday(_matchdayNumber)
        : <String, MatchOutcome>{
            for (final m in liveMatches)
              if (appState.effectivePredictionOutcomesByMatchId[m.id] != null)
                m.id: appState.effectivePredictionOutcomesByMatchId[m.id]!,
          };

    final livePicks = appState.currentUserPicksByMatchId.isNotEmpty
        ? appState.currentUserPicksByMatchId
        : _picks;

    final liveMatchday = MatchdayData(
      dayNumber: _matchdayNumber,
      matches: liveMatches,
      outcomesByMatchId: liveOutcomes,
    );

    // Autosave outcomes (post-frame): appena abbiamo outcomes per la giornata corrente,
    // persistiamoli così lo storico diventa stabile senza dipendere dal submit.
    if (!appState.hasSavedOutcomesForMatchday(_matchdayNumber) &&
        liveOutcomes.isNotEmpty) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        // ricontrolla (potrebbe essere già stato salvato)
        if (!appState.hasSavedOutcomesForMatchday(_matchdayNumber)) {
          appState.saveOutcomesHistory(
            dayNumber: _matchdayNumber,
            outcomesByMatchId: liveOutcomes,
          );
        }
      });
    }
    final demoHistory = mockSeasonMatchdays(
      startDay: 16,
      count: 4,
      demoSeed: appState.demoSeed,
    )..sort((a, b) => b.dayNumber.compareTo(a.dayNumber));

    Widget tileFor(
      MatchdayData md,
      Map<String, PickOption> picks, {
      String? tag,
    }) {
      final daysLabel = formatMatchdayDaysItalian(
        md.matches.map((m) => m.kickoff),
      );
      final total = md.matches.length;
      final graded = md.matches.where((m) {
        final o = md.outcomesByMatchId[m.id] ?? MatchOutcome.pending;
        return !o.isPending;
      }).length;

      final resultsLabel = graded == total
          ? 'risultati: $graded/$total'
          : 'risultati: $graded/$total (parziale)';

      final title = tag == null
          ? 'Giornata ${md.dayNumber}'
          : 'Giornata ${md.dayNumber} ($tag)';

      // final appState = CassandraScope.of(context); // provided by caller
      final savedMatches = appState.matchesByMatchday[md.dayNumber];
      final matchesEffective = (savedMatches != null && savedMatches.isNotEmpty)
          ? savedMatches
          : md.matches;

      final savedOutcomes = appState.outcomesByMatchday[md.dayNumber];
      final outcomesEffective =
          (savedOutcomes != null && savedOutcomes.isNotEmpty)
          ? savedOutcomes
          : md.outcomesByMatchId;

      final picksEffective = appState.picksForCurrentUserForMatchday(
        md.dayNumber,
      );

      return Card(
        child: ListTile(
          title: Text(title),
          subtitle: Text('$daysLabel\n$resultsLabel'),
          isThreeLine: true,
          trailing: const Icon(Icons.chevron_right),
          onTap: () {
            Navigator.of(context).push(
              MaterialPageRoute(
                builder: (_) => PredictionsMatchdayPage(
                  matchdayNumber: md.dayNumber,
                  matches: matchesEffective,
                  outcomesByMatchId: outcomesEffective,
                  picksByMatchId: picksEffective,
                ),
              ),
            );
          },
        ),
      );
    }

    final liveTag = appState.cachedPredictionMatchesAreReal ? 'LIVE' : 'DEMO';

    appState.ensureCurrentUserPicksHistoryLoaded();

    final hasSavedLive = appState.hasSavedPicksForMatchday(_matchdayNumber);
    final livePicksEffective = hasSavedLive
        ? appState.currentUserPicksForMatchday(_matchdayNumber)
        : livePicks;
    final liveTagEffective = hasSavedLive ? 'SALVATI' : liveTag;

    return ListView(
      padding: const EdgeInsets.fromLTRB(12, 8, 12, 16),
      children: [
        Card(
          child: Padding(
            padding: const EdgeInsets.all(12),
            child: Text(
              'Storico pronostici (DEMO)\n'
              'Qui mostriamo 16–19 dai mock. La giornata corrente è visibile sopra (LIVE/DEMO).',
              style: Theme.of(context).textTheme.bodySmall,
            ),
          ),
        ),
        const SizedBox(height: 8),
        tileFor(liveMatchday, livePicksEffective, tag: liveTagEffective),
        const SizedBox(height: 12),
        for (final md in demoHistory)
          tileFor(
            appState.hasSavedOutcomesForMatchday(md.dayNumber)
                ? MatchdayData(
                    dayNumber: md.dayNumber,
                    matches: md.matches,
                    outcomesByMatchId: appState.outcomesForMatchday(
                      md.dayNumber,
                    ),
                  )
                : md,
            appState.hasSavedPicksForMatchday(md.dayNumber)
                ? appState.currentUserPicksForMatchday(md.dayNumber)
                : _demoPicksForMatchday(
                    '${uid}_${md.dayNumber}_${appState.demoSeed}',
                    md.matches,
                  ),
            tag: appState.hasSavedPicksForMatchday(md.dayNumber)
                ? 'SALVATI'
                : 'DEMO',
          ),
      ],
    );
  }

  /// Tiene solo i match “della giornata” ed esclude i recuperi molto lontani nel tempo.
  /// Regola: prendiamo il primo kickoff della giornata e includiamo solo i match entro 7 giorni.
  // ignore: unused_element
  List<T> _filterMatchdayWindow<T>(
    List<T> fixtures, {
    required int? Function(T) roundOf,
    required DateTime Function(T) kickoffOf,
    int minFixtures = 8,
  }) {
    if (fixtures.isEmpty) return fixtures;

    final sorted = fixtures.toList()
      ..sort((a, b) => kickoffOf(a).compareTo(kickoffOf(b)));

    // Cluster più denso (tipicamente 2-4 giorni) per tagliare recuperi molto distanti
    List<T> denseCluster(List<T> xs) {
      if (xs.length <= 2) return xs;
      const window = Duration(days: 4);

      var bestStart = 0;
      var bestEnd = 0;

      for (var i = 0; i < xs.length; i++) {
        final start = kickoffOf(xs[i]);
        var j = i;
        while (j < xs.length &&
            kickoffOf(xs[j]).difference(start) <= window) {
          j++;
        }
        final len = (j - i);
        if (len > (bestEnd - bestStart + 1)) {
          bestStart = i;
          bestEnd = j - 1;
        }
      }
      return xs.sublist(bestStart, bestEnd + 1);
    }

    final byRound = <int, List<T>>{};
    for (final f in sorted) {
      final r = roundOf(f);
      if (r == null) continue;
      (byRound[r] ??= <T>[]).add(f);
    }

    if (byRound.isEmpty) return denseCluster(sorted);

    // 1) Preferisci la prima “giornata vera” (>= minFixtures) anche se c'è un recupero prima
    int? chosenRound;
    DateTime? chosenFirstKickoff;

    for (final e in byRound.entries) {
      final list = e.value.toList()
        ..sort((a, b) => kickoffOf(a).compareTo(kickoffOf(b)));
      if (list.length < minFixtures) continue;

      final first = kickoffOf(list.first);
      if (chosenFirstKickoff == null || first.isBefore(chosenFirstKickoff!)) {
        chosenRound = e.key;
        chosenFirstKickoff = first;
      }
    }

    // 2) Fallback: round con più partite (tie -> kickoff più vicino)
    if (chosenRound == null) {
      var bestRound = byRound.keys.first;
      var bestCount = -1;
      DateTime? bestFirst;

      for (final e in byRound.entries) {
        final list = e.value.toList()
          ..sort((a, b) => kickoffOf(a).compareTo(kickoffOf(b)));
        final count = list.length;
        final first = kickoffOf(list.first);

        final better = (count > bestCount) ||
            (count == bestCount &&
                (bestFirst == null || first.isBefore(bestFirst!)));

        if (better) {
          bestRound = e.key;
          bestCount = count;
          bestFirst = first;
        }
      }
      chosenRound = bestRound;
    }

    final chosen = byRound[chosenRound]!.toList()
      ..sort((a, b) => kickoffOf(a).compareTo(kickoffOf(b)));

    // REGOLA: se NON è una giornata “vera”, NON arretrare su recuperi (16ª ecc.)
    // Se invece è “vera”, aggiorna la giornata corrente.
    if (chosen.length >= minFixtures) {
      _matchdayNumber = chosenRound;
    }

    return denseCluster(chosen);
  }
    if (fixtures.isEmpty) return fixtures;

    DateTime? kickoffOf(T f) {
      try {
        final d = f as dynamic;
        final v =
            d.kickoff ??
            d.date ??
            d.fixture?.date ??
            d.fixture?.timestamp ??
            d.fixture?.timestampMs ??
            d.fixture?.time ??
            d.fixture?.dateTimestamp ??
            d.start ??
            d.startTime;
        if (v is DateTime) return v;
        if (v is String) return DateTime.tryParse(v);
        if (v is int) {
          if (v > 1000000000000) return DateTime.fromMillisecondsSinceEpoch(v);
          if (v > 1000000000)
            return DateTime.fromMillisecondsSinceEpoch(v * 1000);
        }
      } catch (_) {}
      return null;
    }

    int? roundOf(T f) {
      int? parseRound(dynamic r) {
        if (r is int) return r;
        if (r is String) {
          final m = RegExp(r'(\d+)\s*$').firstMatch(r);
          return m == null ? null : int.tryParse(m.group(1)!);
        }
        return null;
      }

      try {
        final d = f as dynamic;
        final v = d.roundNumber ?? d.matchdayNumber ?? d.dayNumber ?? d.round;
        final p = parseRound(v);
        if (p != null) {
          return p;
        }
        final league = d.league;
        if (league != null) {
          final lv =
              (league as dynamic).roundNumber ?? (league as dynamic).round;
          final p2 = parseRound(lv);
          if (p2 != null) {
            return p2;
          }
        }
      } catch (_) {}
      return null;
    }

    List<T> denseCluster(List<T> items) {
      if (items.length <= 1) return items;
      final sorted = List<T>.of(items)
        ..sort((a, b) => kickoffOf(a)!.compareTo(kickoffOf(b)!));
      int bestI = 0, bestJ = 0, bestCount = 0;

      for (int i = 0; i < sorted.length; i++) {
        final start = kickoffOf(sorted[i])!;
        final end = start.add(Duration(days: maxSpanDays));
        int j = i;
        while (j < sorted.length) {
          final k = kickoffOf(sorted[j])!;
          if (k.isAfter(end)) break;
          j++;
        }
        final count = j - i;
        if (count > bestCount) {
          bestCount = count;
          bestI = i;
          bestJ = j;
        }
      }
      return sorted.sublist(bestI, bestJ);
    }

    final now = DateTime.now();

    final candidates = fixtures.where((f) {
      final k = kickoffOf(f);
      if (k == null) return false;
      // evita giornate vecchie finite "da settimane"
      return k.isAfter(now.subtract(const Duration(days: 7)));
    }).toList();

    if (candidates.isEmpty) return fixtures;

    final sorted = List<T>.of(candidates)
      ..sort((a, b) => kickoffOf(a)!.compareTo(kickoffOf(b)!));

    int? bestRound;
    int bestRoundCount = 0;

    for (int i = 0; i < sorted.length; i++) {
      final start = kickoffOf(sorted[i])!;
      final end = start.add(Duration(days: maxSpanDays));
      final counts = <int, int>{};

      for (int j = i; j < sorted.length; j++) {
        final k = kickoffOf(sorted[j])!;
        if (k.isAfter(end)) break;
        final r = roundOf(sorted[j]);
        if (r != null) counts[r] = (counts[r] ?? 0) + 1;
      }

      if (counts.isEmpty) continue;

      var top = counts.entries.first;
      for (final e in counts.entries) {
        if (e.value > top.value) top = e;
      }

      final qualifies = top.value >= minFixtures;
      final better =
          (qualifies && top.value > bestRoundCount) ||
          (!qualifies &&
              bestRoundCount < minFixtures &&
              top.value > bestRoundCount);

      if (better) {
        bestRound = top.key;
        bestRoundCount = top.value;
      }

      if (i == 0 && bestRoundCount >= minFixtures) {
        break;
      }
    }

    List<T> sameRound = sorted;
    if (bestRound != null) {
      _matchdayNumber = bestRound;
      sameRound = sorted.where((f) => roundOf(f) == bestRound).toList();
    }

    // Taglia recuperi molto distanti: tieni solo il cluster più denso
    return denseCluster(sameRound);
  }

  @override
  Widget build(BuildContext context) {
    // final appState = CassandraScope.of(context); // provided by caller
    final lockLabel = _locked
        ? 'giocate bloccate'
        : 'modificabile fino alle ${formatKickoff(_lockTime)}';

    final scoreOutcomesByMatchId = <String, MatchOutcome>{
      for (final m in _matches)
        if (appState.effectivePredictionOutcomesByMatchId[m.id] != null)
          m.id: appState.effectivePredictionOutcomesByMatchId[m.id]!,
    };

    final DayScoreBreakdown dayScore = CassandraScoringEngine.computeDayScore(
      matches: _matches,
      picksByMatchId: {for (final m in _matches) m.id: _pickFor(m.id)},
      outcomesByMatchId: scoreOutcomesByMatchId,
    );

    final bonusSigned = dayScore.bonusPoints == 0
        ? '0'
        : (dayScore.bonusPoints > 0
              ? '+${dayScore.bonusPoints}'
              : '${dayScore.bonusPoints}');

    final scoreAvgLabel = dayScore.averageOddsPlayed == null
        ? '—'
        : formatOdds(dayScore.averageOddsPlayed!);

    final scoreLabel =
        'punti: ${formatOdds(dayScore.total)} (base ${formatOdds(dayScore.baseTotal)} • bonus $bonusSigned)'
        ' • corretti ${dayScore.correctCount}/${dayScore.matchBreakdowns.length}'
        ' • quota media $scoreAvgLabel';

    final avg = _averageOddsPlayed;
    final avgLabel = avg == null ? '-' : formatOdds(avg);

    final dataLabel = _usingRealFixtures ? 'dati: reali (API)' : 'dati: demo';
    final updatedLabel = (_usingRealFixtures && _fixturesUpdatedAt != null)
        ? ' • agg. ${formatKickoff(_fixturesUpdatedAt!)}'
        : '';

    return Scaffold(
      appBar: AppBar(
        actions: [
          IconButton(
            tooltip: 'Aggiorna match',
            onPressed: _loadingFixtures
                ? null
                : () => _tryLoadRealFixtures(showLoader: true),
            icon: _loadingFixtures
                ? const SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(strokeWidth: 2),
                  )
                : const Icon(Icons.refresh),
          ),

          if (kDebugMode)
            IconButton(
              icon: const Icon(Icons.calculate),
              onPressed: _showDebugScorePreview,
            ),
        ],
      ),

      body: SafeArea(
        child: Column(
          children: [
            Padding(
              padding: const EdgeInsets.fromLTRB(12, 12, 12, 8),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  SegmentedButton<int>(
                    segments: const [
                      ButtonSegment(
                        value: 1,
                        label: Text('i pronostici passati'),
                      ),
                      ButtonSegment(
                        value: 0,
                        label: Text('i pronostici futuri'),
                      ),
                    ],
                    selected: {_segment},
                    onSelectionChanged: (newSelection) {
                      setState(() => _segment = newSelection.first);
                    },
                  ),
                  const SizedBox(height: 10),
                  Text(
                    _matchdayLabel,
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                  const SizedBox(height: 6),
                  Text(lockLabel, style: Theme.of(context).textTheme.bodySmall),
                  const SizedBox(height: 4),
                  Text(
                    scoreLabel,
                    style: Theme.of(context).textTheme.bodySmall,
                  ),
                  const SizedBox(height: 6),
                  Text(
                    '$dataLabel$updatedLabel',
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: CassandraColors.slate,
                    ),
                  ),
                  const SizedBox(height: 6),
                  Text(
                    'scelte: $_pickedCount/${_matches.length}  •  quota media: $avgLabel',
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: CassandraColors.slate,
                    ),
                  ),
                  if (_submittedVisibility != null && _submittedAt != null) ...[
                    const SizedBox(height: 6),
                    Text(
                      'ultimo invio: ${formatKickoff(_submittedAt!)} '
                      '(${_submittedVisibility == VisibilityChoice.public ? 'pubblica' : 'privata'})',
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: CassandraColors.slate,
                      ),
                    ),
                  ],
                ],
              ),
            ),
            const Divider(height: 1),
            Expanded(
              child: _segment == 1
                  ? _buildHistory(context)
                  : ListView.builder(
                      padding: const EdgeInsets.only(bottom: 16),
                      itemCount: _matches.length,
                      itemBuilder: (context, i) {
                        final match = _matches[i];
                        final pick = _pickFor(match.id);

                        return PredictionMatchCard(
                          match: match,
                          pick: pick,
                          locked: _locked,
                          onPick: (p) => _setPick(match.id, p),
                          onClear: () => _clearPick(match.id),
                        );
                      },
                    ),
            ),
          ],
        ),
      ),
      bottomNavigationBar: _segment == 1
          ? null
          : SafeArea(
              child: Padding(
                padding: const EdgeInsets.fromLTRB(12, 10, 12, 12),
                child: Row(
                  children: [
                    Expanded(
                      child: OutlinedButton(
                        onPressed: _locked
                            ? null
                            : () => _submit(VisibilityChoice.private),
                        style: OutlinedButton.styleFrom(
                          side: const BorderSide(
                            color: CassandraColors.primary,
                          ),
                          foregroundColor: CassandraColors.primary,
                          padding: const EdgeInsets.symmetric(vertical: 14),
                        ),
                        child: const Text('invia senza mostrare'),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: FilledButton(
                        onPressed: _locked
                            ? null
                            : () => _submit(VisibilityChoice.public),
                        style: FilledButton.styleFrom(
                          backgroundColor: CassandraColors.primary,
                          foregroundColor: CassandraColors.bg,
                          padding: const EdgeInsets.symmetric(vertical: 14),
                        ),
                        child: const Text('invia e mostra'),
                      ),
                    ),
                  ],
                ),
              ),
            ),
    );
  }
}